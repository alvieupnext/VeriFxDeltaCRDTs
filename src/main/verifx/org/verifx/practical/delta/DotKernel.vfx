import org.verifx.practical.crdts.DeltaCRDT
import org.verifx.practical.crdts.CvRDTProof2
import org.verifx.practical.crdts.CvRDTProof1


class DotContext[K](cc: Map[K, Int], dc: Set[Tuple[K, Int]]) extends DeltaCRDT[DotContext[K]] {

    @recursive
    private def checkAscendingDots(key: K, dots: Set[Tuple[K, Int]], counter: Int, amountOfDots: Int): Boolean = {
        if (counter > amountOfDots) {
            true
        } else if (dots.contains(new Tuple[K, Int](key, counter))) {
             this.checkAscendingDots(key, dots, counter + 1, amountOfDots)}
             else false
        }

    private def checkDotValidity(key: K): Boolean = {
        //get all dots from dc that contain the key
        val dotsInSet = this.dc.filter((tpl: Tuple[K, Int]) => tpl.fst == key)
        //get latest update from cc
        val amountOfDots = this.cc.getOrElse(key, 0)
        if (amountOfDots != 0) {
            this.checkAscendingDots(key, this.dc, 1, amountOfDots)
            }
        else false
    }

    override def reachable(): Boolean = {
        //dots cannot be negative
//        val ccValues = this.cc.values()
//        val ccCondition = ccValues.forall((v: Int) => v >= 0)
//        val dcCondition = this.dc.forall((t: Tuple[K, Int]) => t.snd >= 0)
//        ccCondition && dcCondition
        //get all keys from cc and dc
        val ccKeys = this.cc.keys()
        //all values must be positive and not 0
        val ccValues = this.cc.values()
        val ccCondition = ccValues.forall((v: Int) => v >= 0)
        val dcCondition = this.dc.forall((t: Tuple[K, Int]) => t.snd >= 0)
        val dcKeys = this.dc.map[K]((tuple: Tuple[K, Int]) => tuple.fst)
        //get the difference between ccKeys and dcKeys (if the difference is empty, cc and dc have the same keys)
        val diff = ccKeys.diff(dcKeys)
        val diff2 = dcKeys.diff(ccKeys)
        //if the difference isn't empty (inconsistent keys) return false
//        if (diff.isEmpty()) {
//            //all dots in cc must be represented in dc as a set with an integer that sums +1 until the value of the dot in cc
//
//        } else false
//          this.cc.bijective()
        ccCondition && dcCondition && diff.isEmpty() && diff2.isEmpty() && ccKeys.forall((key: K) => {
                                          this.checkDotValidity(key)
                                          })}
//}

    def dotIn(d: Tuple[K, Int]): Boolean = {
        this.dc.contains(d)
//        if (this.cc.contains(d.fst) && d.snd <= this.cc.get(d.fst)) {
//            true
//        } else if (this.dc.contains(d)) {
//            true
//        } else false
    }

     def makeDot(id: K): Tuple[K, Int] = {
       val value = this.cc.getOrElse(id, 0)
       if (value == 0) {
        this.cc.add(id, 1); new Tuple(id, 1)
       }
       else {
        this.cc.add(id, value + 1); new Tuple(id, value + 1)
       }
     }

     def insertDot(d: Tuple[K, Int]): DotContext[K] = {
       new DotContext(this.cc, this.dc.add(d))
     }

     private def max(a: Int, b: Int): Int = {if (a >= b) a else b}

     def join(o: DotContext[K]): DotContext[K] = {
       // Merging cc (this takes the max from both, keeping the singular ones alive
       val newcc = this.cc.combine(o.cc, (v1: Int, v2: Int) => this.max(v1, v2))
       // Merging dc
       val newdc = o.dc.union(this.dc)
       new DotContext(newcc, newdc)
     }

     def merge(o: DotContext[K]): DotContext[K] = {
            // Merging cc (this takes the max from both, keeping the singular ones alive
            val newcc = this.cc.combine(o.cc, (v1: Int, v2: Int) => this.max(v1, v2))
            // Merging dc
            val newdc = o.dc.union(this.dc)
            new DotContext(newcc, newdc)
          }
}

class DotKernel[K, T](ds: Map[Tuple[K, Int], T], c: DotContext[K]) extends DeltaCRDT[DotKernel[K, T]] {
    override def reachable(): Boolean = {
        val validContext = this.c.reachable()
         val dsDots = this.ds.keys()
         //every dot in the dot map needs to be present in the causal context
         //check whether every single dot in the dsDots is present in the Causal Context
         val firstCond = dsDots.forall((v: Tuple[K, Int]) => this.c.dotIn(v))
         //dots can never have a negative integer
         val secondCond = dsDots.forall((v: Tuple[K, Int]) => v.snd >= 0)
         validContext && firstCond && secondCond
       }

//    def merge(other: DotKernel[K, T]): DotKernel[K, T] = {
//        val thisKeys = this.ds.keys()
//        val otherKeys = other.ds.keys()
//        val bothKeys = thisKeys.intersect(otherKeys)
//        val onlyThisKeys = thisKeys.diff(bothKeys)
//        val onlyOtherKeys = otherKeys.diff(bothKeys)
//        val onlyThisKeysKnownByOtherC = onlyThisKeys.filter((k: Tuple[K, Int]) => other.c.dotIn(k))
//        val onlyOtherKeysNotKnownByOurC = onlyOtherKeys.filter((k: Tuple[K, Int]) => !this.c.dotIn(k))
//        //remove all keys known by the other c from the new ds (started from the our ds
//        val newds = this.ds.filter((key: Tuple[K, Int], value: T) => !onlyThisKeysKnownByOtherC.contains(key))
//        //only keep the map values known by our c
//        val onlyOtherKeyValues = other.ds.filter((key: Tuple[K, Int], value: T) => onlyOtherKeysNotKnownByOurC.contains(key))
//        //from the two values, get the second one as preference, since that one should override the first one
//        val mergedDs = newds.combine(onlyOtherKeyValues, (v1: T, v2: T) => v2)
//        val res = new DotKernel[K, T](newds, this.c.merge(other.c))
//        res
//    }
    def merge(other: DotKernel[K, T]): DotKernel[K, T] = {
        //merge the data stores with common dots
        val commonDots = this.ds.zip(other.ds)
        //values of the new map are tuples of values so change it to return one value
        val commonDS = commonDots.map((key: Tuple[K, Int], value: Tuple[T, T]) => value.fst)
        //values
        val myDotsNotInOtherContext = this.ds.filter((key: Tuple[K, Int], value: T) => !other.c.dotIn(key))
        val otherDotsNotInMyContext = other.ds.filter((key: Tuple[K, Int], value: T) => !this.c.dotIn(key))
        //Dots to add
        val dotsToAdd = myDotsNotInOtherContext.combine(otherDotsNotInMyContext, (v1: T, v2:T) => v1)
        val newds = commonDS.combine(dotsToAdd, (v1: T, v2:T) => v1)
        val res = new DotKernel[K, T](newds, this.c.merge(other.c))
        res
    }


//    def DSToList(ds: Map[Tuple[K, Int], T]): LList[Tuple[Tuple[K, Int], T]] = {
//        val res = new LList[Tuple[Tuple[K, Int], T]]()
//        ds.forall((k: Tuple[K, Int], v: T) => {
//            res.insert(0, new Tuple[Tuple[K, Int], T](k, v))
//            true
//        })
//        res
//    }
//
//    @recursive
//    def mergeDSs(thisDS: LList[Tuple[Tuple[K, Int], T]], otherDS: LList[Tuple[Tuple[K, Int], T]],
//     thisPos: Int, otherPos: Int, res: Map[Tuple[K, Int], T], oc: DotContext[K]): Map[Tuple[K, Int], T] = {
//        if (!(thisPos == thisDS.size && otherPos == otherDS.size)) { // while not at the end of both sequences
//            val thisCurEl = thisDS.get(thisPos)
//            val otherCurEl = otherDS.get(otherPos)
//            // tow dots are smaller if the timestamp is smaller
//            if (thisPos != thisDS.size && (otherPos == otherDS.size || thisCurEl.fst.snd < otherCurEl.fst.snd)) {
//                if (oc.dotIn(thisCurEl.fst)) { // other knows dot, must delete here
//                    res.remove(thisCurEl.fst)
//                    this.mergeDSs(thisDS, otherDS, thisPos + 1, otherPos, res, oc)
//                } else {
//                    this.mergeDSs(thisDS, otherDS, thisPos + 1, otherPos, res, oc)
//                }
//            } else if (otherPos != otherDS.size && (thisPos == thisDS.size || otherCurEl.fst.snd < thisCurEl.fst.snd)) {
//                if (!this.c.dotIn(otherCurEl.fst)) {
//                    res.add(otherCurEl.fst, otherCurEl.snd)
//                    this.mergeDSs(thisDS, otherDS, thisPos, otherPos + 1, res, oc)
//                } else {
//                    this.mergeDSs(thisDS, otherDS, thisPos, otherPos + 1, res, oc)
//                }
//            } else {
//                this.mergeDSs(thisDS, otherDS, thisPos + 1, otherPos + 1, res, oc)
//            }
//        } else res
//    }
//
//    def merge(other: DotKernel[K, T]): DotKernel[K, T] = {
//        val thisDSlist = this.DSToList(this.ds)
//        val otherDSlist = this.DSToList(other.ds)
//        val DSres = this.mergeDSs(thisDSlist, otherDSlist, 0, 0, this.ds, other.c)
//        val Cres = this.c.merge(other.c)
//        new DotKernel(DSres, Cres)
//    }

    def add(id: K, value: T): DotKernel[K, T] = {
        val dot = this.c.makeDot(id)
        this.c.insertDot(dot)
        this.ds.add(dot, value)
        val map = new Map[Tuple[K, Int], T]()
        map.add(dot, value)
        val context = new DotContext[K](new Map[K, Int](), new Set[Tuple[K, Int]]())
        context.insertDot(dot)
        context.cc.add(dot.fst, dot.snd)
        new DotKernel[K, T](map, context)
    }

    def rmv(dot: Tuple[K, Int]): DotKernel[K, T] = {
        val res = new DotKernel[K, T](new Map[Tuple[K, Int], T](), new DotContext[K](new Map[K, Int](), new Set[Tuple[K, Int]]()))
        if (this.ds.contains(dot)) {
            val dsit = this.ds.get(dot)
            this.ds.remove(dot)
            res.c.insertDot(dot)
            res
        } else res
    }
}

object DotContext extends CvRDTProof1[DotContext]

object DotKernel extends CvRDTProof2[DotKernel]