import org.verifx.practical.crdts.DeltaCRDT
import org.verifx.practical.crdts.CvRDTProof2
import org.verifx.practical.crdts.CvRDTProof1


class DotContext[K](cc: Map[K, Int], dc: Set[Tuple[K, Int]]) extends DeltaCRDT[DotContext[K]] {

    def dotIn(d: Tuple[K, Int]): Boolean = {
        if (this.cc.contains(d.fst) && (d.snd <= this.cc.get(d.fst))) {
            true
        } else if (this.dc.contains(d)) {
            true
        } else false
    }

     def makeDot(id: K): Tuple[K, Int] = {
       val value = this.cc.getOrElse(id, 0)
       if (value == 0) {
        this.cc.add(id, 1); new Tuple(id, 1)
       }
       else {
        this.cc.add(id, value + 1); new Tuple(id, value + 1)
       }
     }

     def insertDot(d: Tuple[K, Int]): DotContext[K] = {
       new DotContext(this.cc, this.dc.add(d))
     }

     private def max(a: Int, b: Int): Int = {if (a >= b) a else b}

     def join(o: DotContext[K]): DotContext[K] = {
       // Merging cc (this takes the max from both, keeping the singular ones alive
       val newcc = this.cc.combine(o.cc, (v1: Int, v2: Int) => this.max(v1, v2))
       // Merging dc
       val newdc = o.dc.union(this.dc)
       new DotContext(newcc, newdc)
     }

     def merge(o: DotContext[K]): DotContext[K] = {
            // Merging cc (this takes the max from both, keeping the singular ones alive
            val newcc = this.cc.combine(o.cc, (v1: Int, v2: Int) => this.max(v1, v2))
            // Merging dc
            val newdc = o.dc.union(this.dc)
            new DotContext(newcc, newdc)
          }
}

class DotKernel[K, T](ds: Map[Tuple[K, Int], T], c: DotContext[K]) extends DeltaCRDT[DotKernel[K, T]] {
    def merge(other: DotKernel[K, T]): DotKernel[K, T] = {
        val thisKeys = this.ds.keys()
        val otherKeys = other.ds.keys()
        val bothKeys = thisKeys.intersect(otherKeys)
        val onlyThisKeys = thisKeys.diff(bothKeys)
        val onlyOtherKeys = otherKeys.diff(bothKeys)
        val onlyThisKeysKnownByOtherC = onlyThisKeys.filter((k: Tuple[K, Int]) => other.c.dotIn(k))
        val onlyOtherKeysNotKnownByOurC = onlyOtherKeys.filter((k: Tuple[K, Int]) => !this.c.dotIn(k))
        //remove all keys known by the other c from the new ds (started from the our ds
        val newds = this.ds.filter((key: Tuple[K, Int], value: T) => !onlyThisKeysKnownByOtherC.contains(key))
        //only keep the map values known by our c
        val onlyOtherKeyValues = other.ds.filter((key: Tuple[K, Int], value: T) => onlyOtherKeysNotKnownByOurC.contains(key))
        //from the two values, get the second one as preference, since that one should override the first one
        val mergedDs = newds.combine(onlyOtherKeyValues, (v1: T, v2: T) => v2)
        val res = new DotKernel[K, T](newds, this.c.join(other.c))
        res
    }

    def add(id: K, value: T): DotKernel[K, T] = {
        val dot = this.c.makeDot(id)
        this.ds.add(dot, value)
        val res = new DotKernel[K, T](new Map[Tuple[K, Int], T](), new DotContext[K](new Map[K, Int](), new Set[Tuple[K, Int]]()))
        res.ds.add(dot, value)
        res.c.insertDot(dot)
        res
    }

    def rmv(dot: Tuple[K, Int]): DotKernel[K, T] = {
        val res = new DotKernel[K, T](new Map[Tuple[K, Int], T](), new DotContext[K](new Map[K, Int](), new Set[Tuple[K, Int]]()))
        if (this.ds.contains(dot)) {
            val dsit = this.ds.get(dot)
            this.ds.remove(dot)
            res.c.insertDot(dot)
            res
        } else res
    }
}

object DotContext extends CvRDTProof1[DotContext]

object DotKernel extends CvRDTProof2[DotKernel]